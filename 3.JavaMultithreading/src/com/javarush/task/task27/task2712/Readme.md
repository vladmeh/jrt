taskKey="com.javarush.task.task27.task2712.big06"

#### Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления, и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда — последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask — у нас Producer, т.к. производит заказы
Cook — это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему константу из п.1. в качестве значения для созданного поля.
3. Tablet — не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook — таском (Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.
***


#### Ресторан(21)

Продолжаем фиксить баг.

Сейчас все заказы поступают в очередь, но не доходят до поваров.
Сделаем так, чтобы OrderManager находил любого свободного повара и отдавал ему заказ. Для реализации данной логики нам понадобится демон-трэд. Он будет проверять наличие заказа в очереди, брать свободного повара и отдавать ему заказ.

Нам понадобится метод, который определит, занят повар или нет.
1. В классе Cook создай поле boolean busy с геттером.
2. В начале метода startCookingOrder поставьте busy в true, а в конце метода в false.
3. В методе startCookingOrder сымитируй задержку при приготовлении блюда, поставь слип в 10-кратном размере от времени приготовления заказа. Приготовления заказа, т.е. если заказ готовится 30 минут, то задержка будет 30*10 миллисекунд.
4. Чтобы получить список всех поваров, в классе StatisticManager добавь геттер для поля, которое заполняется в методе register(Cook cook).

5. В конструкторе OrderManager создай и запусти демон-трэд. Логика метода run:
каждые 10 миллисекунд проверять очередь. Если в очереди есть заказ, то найти свободного повара и передать ему заказ (метод startCookingOrder), если нет свободного повара или нет заказов в очереди, то ждать дальше.
***


#### Ресторан(20)

Фикс бага — планшет направляет свой заказ всем известным ему поварам.
Ожидаемое поведение: планшет направляет свой заказ в очередь, свободный повар берет заказы из очереди.

Есть два варианта реализации такого функционала:
1. Каждый планшет хранит ссылку на очередь и толкает в нее новый свой заказ.
2. Планшет толкает свой заказ в Observer, который хранит в себе ссылку на очередь. Observer заносит заказ в очередь.

Мы пойдем по второму пути.
1. Создай класс OrderManager, который будет Observer для планшетов.
2. В классе OrderManager создай поле orderQueue типа LinkedBlockingQueue<Order>. В него складывай все заказы, поступающие в метод update.
3. Класс Cook теперь — НЕ Observer.
4. В классе Cook создай метод void startCookingOrder(Order order), в который перенеси логику из метода update.
5. Удали метод update из класса Cook.
6. В методе main расставь зависимость Observer-Observable в связи с вышеперечисленными изменениями.
***


#### Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!
***


#### Ресторан(18)

Сейчас у нас один планшет и 1 повар.
Давай создадим несколько планшетов, которые будут рандомно генерировать заказы, и сделаем два повара.

1. В классе Restaurant создай ПРИВАТНУЮ статическую константу int ORDER_CREATING_INTERVAL = 100.

2. В отдельном классе создай таск (Runnable) RandomOrderGeneratorTask. Этот таск должен:
2.1. Хранить список всех планшетов
2.2. Используя Math.random выбирать случайный планшет.
2.3. У RandomOrderGeneratorTask должен быть только один единственный метод.
2.4. Генерировать случайный заказ каждые ORDER_CREATING_INTERVAL миллисекунд для планшета из п.2.2. (не печатай стек-трейс)
Сейчас заказ создается в методе createOrder в классе Tablet.
В классе Tablet создай метод void createTestOrder() с похожей функциональностью,
который будет случайным образом генерировать заказ со случайными блюдами не общаясь с реальным человеком.
Все необходимые данные передай в конструкторе.

Подсказка:
а) создай класс TestOrder — наследник Order — в пакете родителя.
б) в классе Order создай protected метод initDishes(), в котором инициализируй dishes. Вызови этот метод в конструкторе
в) сделай поле dishes protected
г) переопредели initDishes в классе-наследнике TestOrder. Сделай инициализацию случайным набором блюд.
д) вместо создания объекта Order в методе createTestOrder() класса Tablet, создавай объект класса TestOrder.
Весь другой функционал метода createTestOrder оставь прежним

3. Отрефакторь методы createTestOrder() и createOrder(): в одном из методов выдели код, который повторяется в обоих методах, и нажми Ctrl+Alt+M, введи любое имя метода и нажми ОК. IDEA предложит заменить этот код во втором методе, подтверди.
***



[#### Ресторан(17)](https://github.com/vladmeh/jrt/commit/d54b0d1d4c4cb9c29a300c62d7269547aaf74277)

Реализуем третий и четвертый пункт статистики — список активных и неактивных роликов
Для этого проще использовать доступ к хранилищу рекламных роликов — класс AdvertisementStorage.
У этого класса уровень доступа package local. Поэтому, чтобы к нему доступиться, нам нужен отдельный класс в этом же пакете.
1. В пакете ad создай StatisticAdvertisementManager, который будет предоставлять информацию из AdvertisementStorage в нужном нам виде.
Сделай его синглтоном.

2. В классе StatisticAdvertisementManager создайте и проинициализируйте поле типа AdvertisementStorage.

3. В StatisticAdvertisementManager создай два (или один) метода (придумать самостоятельно), которые из хранилища AdvertisementStorage достанут все необходимые данные — соответственно список активных и неактивных рекламных роликов.
Активным роликом считается тот, у которого есть минимум один доступный показ.
Неактивным роликом считается тот, у которого количество показов равно 0.

4. Реализуй логику методов printActiveVideoSet и printArchivedVideoSet в классе DirectorTablet.
Используй методы/метод, созданные в предыдущем пункте.
Сортировать по имени видео-ролика в алфавитном порядке
Сначала английские, потом русские.

Пример вывода для printActiveVideoSet:
* First Video - 100
* second video - 10
* Third Video - 2
* четвертое видео - 4

Через 50 показов пример вывода для printArchivedVideoSet:
* second video
* Third Video
* четвертое видео
***


[#### Ресторан(16)](https://github.com/vladmeh/jrt/commit/c950208a0e09a13024a1e3ca1a95d22bdb82f95f)

Реализуем первый пункт статистики — какую сумму заработали на рекламе, сгруппировать по дням.

1. В классе VideoSelectedEventDataRow создай геттер для поля amount.
В классе CookedOrderEventDataRow создай геттер для поля cookName.

2. В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные, относящиеся к отображению рекламы, и посчитает общую прибыль за каждый день.
Дополнительно добавь вспомогательный метод get в класс хранилища, чтобы получить доступ к данным.

3. Начнем с логики метода printAdvertisementProfit в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты и суммы.
Для каждой даты из хранилища событий, для которой есть показанная реклама, должна выводится сумма прибыли за показы рекламы для этой даты.
В конце вывести слово Total и общую сумму.

Пример:
14-May-2013 - 2.50
13-May-2013 - 1.02
12-May-2013 - 543.98
Total - 547.50

4.Реализуем второй пункт статистики — загрузка (рабочее время) повара, сгруппировать по дням.

В StatisticManager создай метод (придумать самостоятельно), который из хранилища достанет все данные, относящиеся к работе повара, и посчитает общую продолжительность работы для каждого повара отдельно.

5. Реализуем логику метода printCookWorkloading в классе DirectorTablet.
Используя метод из предыдущего пункта вывести в консоль в убывающем порядке даты, имена поваров и время работы в минутах (округлить в большую сторону).
Для каждой даты из хранилища событий, для которой есть запись о работе повара, должна выводится продолжительность работы в минутах для этой даты.
Если повар не работал в какой-то из дней, то с пустыми данными его НЕ выводить (см. 13-May-2013)
Поваров сортировать по имени

Пример:
14-May-2013
vanov - 60 min
Petrov - 35 min

13-May-2013
Ivanov - 129 min

12-May-2013
Ivanov - 6 min
Petrov - 5 min
***



[#### Ресторан(15)](https://github.com/vladmeh/jrt/commit/a5b251aa9575bd01be4d4cfc93096861c911464c)

Давай подумаем что нужно сделать, чтобы директор мог посмотреть:
1. какую сумму заработали на рекламе, сгруппировать по дням;
2. загрузка (рабочее время) повара, сгруппировать по дням;
3. список активных роликов и оставшееся количество показов по каждому;
4. список неактивных роликов (с оставшемся количеством показов равным нулю).

Для каждого пункта добавим соответствующий метод в StatisticManager.
Директор будет вызывать метод, StatisticManager будет делать различные подсчеты.
Но директор должен из какого-то места вызвать эти методы. Дадим ему планшет, но с другим ПО.
Для этого создадим класс DirectorTablet, в котором будут дружелюбный интерфейс и возможность обращения к статистике.

1. В корне задачи-проекта создай класс DirectorTablet.

2. В классе DirectorTablet создай четыре void метода:
printAdvertisementProfit(), printCookWorkloading(), printActiveVideoSet(), printArchivedVideoSet()
Они соответствуют перечисленным четырем пунктам.

3. Чтобы можно было проверить результат, добавим в метод main создание директорского планшета и вывод статистики с помощью методов перечисленных выше.

Нам понадобятся еще некоторые методы.
4. В EventDataRow создай методы:
Date getDate(), реализация которого вернет дату создания записи int getTime(), реализация которого вернет время — продолжительность

5. В StatisticManager void register(Cook cook), который зарегистрирует полученного повара.
Создай в классе StatisticManager множество (Set) поваров (cooks) и добавь в него повара.

6. Реализуй необходимые геттеры у классов CookedOrderEventDataRow, NoAvailableVideoEventDataRow и VideoSelectedEventDataRow.
***


[#### Ресторан(14)](https://github.com/vladmeh/jrt/commit/7ecfa74ca23347c3e3981aa44b3db8876788b292)

1.  Внутри StatisticStorage создай метод void put(EventDataRow data).

2.  Чтобы методом put(EventDataRow data) добавить объект data в данные карты, нужен тип события — EventType.
Будет правильно, если событие будет хранить в себе свой тип. Поэтому:
    1. В интерфейс EventDataRow добавь метод EventType getType()
    2. Реализуй этот метод в каждом классе-событии: CookedOrderEventDataRow, NoAvailableVideoEventDataRow, VideoSelectedEventDataRow

3.  Сделай так, чтобы к методу void put(EventDataRow data) нельзя было получить доступ за пределами класса StatisticManager.
Воспользуйся особенностями вложенных классов.

Теперь остается расставить вызовы StatisticManager в те места, которые генерируют события.

4.  Зарегистрируй событие для повара во время приготовления еды.
Добавь геттер для поля dishes в класс Order, используйте его при создании события.

5.  Зарегистрируй событие «видео выбрано» перед отображением рекламы пользователю.

6.  Метод register с одним параметром типа EventDataRow должен регистрировать полученное событие в statisticStorage.
***

[#### Ресторан(13)](https://github.com/vladmeh/jrt/commit/20af86c5f24b02c0c3d571848e9bee286eca4a62)

Вернемся к методу register в классе StatisticManager. Он должен регистрировать события в хранилище.
Создадим хранилище:

Хранилище связано 1 к 1 с менеджером, т.е. один менеджер и одно хранилище на приложение.
К хранилищу может доступиться только StatisticManager. Поэтому…
Из вышеперечисленного следует, что хранилище должно быть приватным иннер классом.
Назовем его StatisticStorage.

1. Внутри класса StatisticManager создать приватный иннер класс StatisticStorage.

2. Чтобы менеджер мог получить доступ к хранилищу, нужно в классе StatisticManager создать поле statisticStorage типа StatisticStorage.
Инициализируй его экземпляром класса.

3. StatisticStorage будет хранить данные внутри себя в виде мапы/словаря storage.
Связь StatisticStorage и Map должна быть has-a
Типы для мапы — <EventType, List<EventDataRow>>

4. В конструкторе StatisticStorage инициализируй хранилище данными по-умолчанию:
например используя цикл, для каждого EventType добавь new ArrayList<EventDataRow>()
***


[#### Ресторан(12)](https://github.com/vladmeh/jrt/commit/f8715064f7504226c613f5865026068057e2e72e)

У нас выделяются несколько событий:
* повар приготовил заказ
* выбрали набор видео-роликов для заказа
* нет ни одного видео-ролика, который можно показать во время приготовления заказа

Это постоянные данные, поэтому для их хранения подходит энам.

1.  В пакете event создай enum EventType {COOKED_ORDER, SELECTED_VIDEOS, NO_AVAILABLE_VIDEO}

2.  В пакете event создай три класса, соответствующих значениям энама. Они будут (должны) представлять собой события.
    Мы будем регистрировать их экземпляры в хранилище.
    Имена классов с параметрами для конструкторов:
    1.  CookedOrderEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List<Dish> cookingDishs)
        где 
        - **tabletName** — имя планшета
        - **cookName** — имя повара
        - **cookingTimeSeconds** — время приготовления заказа в секундах
        - **cookingDishs** — список блюд для приготовления
    2.  NoAvailableVideoEventDataRow(int totalDuration)
        - **totalDuration** — время приготовления заказа в секундах
    3.  VideoSelectedEventDataRow(List<Advertisement> optimalVideoSet, long amount, int totalDuration)
        - **optimalVideoSet** — список видео-роликов, отобранных для показа
        - **amount** — сумма денег в копейках
        - **totalDuration** — общая продолжительность показа отобранных рекламных роликов
3.  В классы, созданные в п.2., добавьте поле Date currentDate, которое проинициализируй в конструкторе текущей датой.
***


[#### Ресторан(11)](https://github.com/vladmeh/jrt/commit/74f161eafbd5ea309c2698955dd2c5c1a11166b9)

Мы реализовали первые две фичи из трех. Напомню, первой была автоматизация приготовления заказа, второй — подбор рекламных роликов, а третья — статистика для директора. Собственно, к ней мы и добрались.

Нам нужно будет реализовать следующую функциональность:
1.  подсчет статистики
2.  отображение статистики директору

Попробуем определиться с последовательностью действий. Чтобы отображать данные, сначала нужно их откуда-то получить.

Есть два подхода:
ПЕРВЫЙ — применяется, когда сложно получить реальные данные, либо когда другой человек работает над получением данных:
1.  захардкодить данные в приложении
2.  отобразить хардкоженную статистику
3.  сделать получение реальных данных — реальную статистику (интеграция с чужим кодом)

ВТОРОЙ:
1.  сделать получение реальных данных — реальную статистику
2.  отобразить статистику

Т.к. мы сами реализовываем данную функциональность, и статистика у нас не сложная, то выберем второй подход.
Начнем с получения реальных данных — реальной статистики.

Идея такая:
Есть хранилище событий.
Когда у нас случается событие, то мы будем регистрировать это событие в хранилище.
На запрос директора мы будем фильтровать события из хранилища, вычислять необходимые данные и отображать их.

Для начала нам нужно несколько классов.
1.  Создадим пакет statistic, в котором создадим класс StatisticManager. С его помощью будем регистрировать события в хранилище.
2.  У нас должно быть одно хранилище с одной точкой входа. Поэтому сделаем StatisticManager синглтоном.
3.  Внутри пакета statistic создадим вложенный пакет event, в котором будут храниться классы, связанные с событиями.
4.  Создадим в пакете event интерфейс EventDataRow. На данный момент он является интерфейсом-маркером, т.к. не содержит методов, и по нему мы определяем, является ли переданный объект событием или нет.
5.  В StatisticManager создадим публичный метод void register(EventDataRow data), который будет регистрировать событие в хранилище.

Мы вернемся к реализации позднее.
***


[#### Ресторан(10)](https://github.com/vladmeh/jrt/commit/b475ef0cccc04314d31bc13761a30076d8db3213)

Рекурсию используют тогда, когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи (части).
У нас как раз такой случай. Нам нужно сделать полный перебор всех вариантов и выбрать из них лучший.

Напомню, рекурсия пишется по следующему принципу:
а) условие выхода/окончания рекурсии
б) условие продолжения — вызов самой себя с набором параметров предыдущего шага.
В любое время ты можешь почитать в инете подробную информацию по написанию рекурсии.

Текущее задание — реализовать п.2.2 предыдущего задания с помощью рекурсии.
(подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду)
Рекурсивный метод должен выбрать набор рекламных роликов, которые будут показаны посетителю.

Этот набор должен удовлетворять следующим требованиям:
1.  сумма денег, полученная от показов, должна быть максимальной из всех возможных вариантов
2.  общее время показа рекламных роликов НЕ должно превышать время приготовления блюд для текущего заказа;
3.  для одного заказа любой видео-ролик показывается не более одного раза;
4.  если существует несколько вариантов набора видео-роликов с одинаковой суммой денег, полученной от показов, то:
    1. выбрать тот вариант, у которого суммарное время максимальное;
    2. если суммарное время у этих вариантов одинаковое, то выбрать вариант с минимальным количеством роликов;
5.  количество показов у любого рекламного ролика из набора — положительное число.

При локальном тестировании учитывайте, что необходимо отобразить все рекламные ролики, отобранные для показа, в порядке уменьшения стоимости показа одного рекламного ролика в копейках.

Также не забудь реализовать п.2.4 из предыдущего задания (вывести на экран все подходящие ролики).

Для каждого показанного видео-ролика должен быть вызван метод revalidate().

Требования:
1.  Сумма денег, полученная от показов, должна быть максимальной из всех возможных вариантов.
2.  Общее время показа рекламных роликов НЕ должно превышать время приготовления блюд для текущего заказа.
3.  Для одного заказа любой видео-ролик должен показываться не более одного раза.
4.  Если существует несколько вариантов набора видео-роликов с одинаковой суммой денег, полученной от показов, то должен быть выбран вариант с максимальным суммарным временем.
5.  Если существует несколько вариантов набора видео-роликов с одинаковой суммой денег и одинаковым суммарным временем, то должен быть выбран вариант с минимальным количеством роликов.
6.  Для каждого показанного ролика должен быть вызван метод revalidate.
***


[#### Ресторан(9)](https://github.com/vladmeh/jrt/commit/4a8a05c8d62a53f8bb76d8c38e881632880c0c21)

Нам понадобится исключение, которое поможет обработать ситуацию, если у нас не будет получаться подобрать рекламные ролики.

1.  Создадим unchecked исключение NoVideoAvailableException в пакете ad.

2.  Разберем подробно метод void processVideos() в AdvertisementManager.
    1. Удаляем из него вывод в консоль «calling processVideos method»
    Метод должен:
    2. Подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду. **(Пока делать не нужно, сделаем позже)**.
    3. Если нет рекламных видео, которые можно показать посетителю, то бросить NoVideoAvailableException, которое перехватить в оптимальном месте (подумать, где это место) и с уровнем Level.INFO логировать фразу «No video is available for the order » + order
    4. Отобразить все рекламные ролики, отобранные для показа, в порядке уменьшения стоимости показа одного рекламного ролика в копейках. Вторичная сортировка — по увеличению стоимости показа одной секунды рекламного ролика в тысячных частях копейки. Используйте метод Collections.sort
    **(Тоже пока делать не нужно, сделаем позже)**.

    Пример для заказа [Water]:
    
    `First Video is displaying... 50, 277`
    
    где First Video — название рекламного ролика
    где 50 — стоимость показа одного рекламного ролика в копейках
    где 277 — стоимость показа одной секунды рекламного ролика в тысячных частях копейки (равно 0.277 коп)
    Используйте методы из класса Advertisement.

    5.  В классе Advertisement создайте метод void revalidate(). Этот метод должен:
        1. Бросать UnsupportedOperationException, если количество показов не положительное число.
        2. Уменьшать количество показов.

> ВНИМАНИЕ!
> пп 2.2 и 2.4 делать не нужно
<hr/>


[#### Ресторан(8)](https://github.com/vladmeh/jrt/commit/fd3213274296afadc8401d91c812154a6a825de1)

Пришло время описать функционал класса AdvertisementManager.
Но для начала нам понадобятся некоторые методы в классе Advertisement.

1. В классе Advertisement создай поле long amountPerOneDisplaying.
Оно должно равняться стоимости одного показа рекламного объявления в копейках (initialAmount/hits).
Присвой значение полю в конструкторе.

2. В классе Advertisement создай геттеры для полей name, duration и amountPerOneDisplaying.

3. Определим необходимые данные для объекта AdvertisementManager — это время выполнения заказа поваром.
Т.к. продолжительность видео у нас хранится в секундах, то и и время выполнения заказа тоже будем принимать в секундах.
В классе AdvertisementManager создай конструктор, который принимает один параметр — int timeSeconds.
Создай соответствующее поле и сохраните это значение в него.

4. AdvertisementManager выполняет только одно единственное действие — обрабатывает рекламное видео.
Поэтому создайте единственный публичный метод void processVideos(), его функционал опишем в следующем задании.
А пока выведем в консоль «calling processVideos method»

5. Чтобы тестировать данную функциональность, нужно добавить вызов processVideos метода у AdvertisementManager.
Очевидно, что этот метод должен вызываться во время создания заказа, а точнее — в параллельном режиме.
Заказ готовится в то время, как видео смотрится.
Добавьте вызов метода processVideos() в нужное место.

>P.S. Не забудь что время приготовления заказа считается в минутах, а время показа рекламы в секундах!
<hr/>


[#### Ресторан(7)](https://github.com/vladmeh/jrt/commit/e0d9c090f5857936a5362ae5dff8c0542f7f0f4b)

При выборе, с какого класса начать, старайся найти тот, который используют другие, и который сам ничего не использует.
В нашем случае — это хранилище рекламных роликов (AdvertisementStorage).
Мы решили, что оно будет единственным в ресторане и сделали его синглтоном.

Опишем его.
1. Видео должно где-то храниться, пусть это будет список.
Создадим поле videos и инициализируем его пустым листом.
Подумай, должно ли поле videos иметь возможность менять свое значение?

2.  Чтобы как-то работать с видео, создай публичные методы:
    1. list() — который вернет список всех существующих доступных видео.
    2. add(Advertisement advertisement) — который добавит новое видео в список videos.

3. В конструкторе класса добавим в список videos какие-то данные. У меня это:
Object someContent = new Object();
new Advertisement(someContent, «First Video», 5000, 100, 3 * 60) // 3 min
new Advertisement(someContent, «Second Video», 100, 10, 15 * 60) //15 min
new Advertisement(someContent, «Third Video», 400, 2, 10 * 60) //10 min

4. В AdvertisementManager создадим final поле-ссылку на экземпляр AdvertisementStorage и назовем ее storage.
Не забудь инициализировать созданное поле!
<hr/>


[#### Ресторан(6)](https://github.com/vladmeh/jrt/commit/1fb48ad2d6cfc68ed665ecbf841c889c460a1127)

Заказ создается, потом готовится поваром, а после этого относится посетителю. К тому же считается время выполнения заказа.
Будем считать, что первая часть задания выполнена.
Перейдем ко второй - пока заказ готовится, на планшете должна показываться реклама.
Определим, что такое реклама.

Реклама - это видео определенной продолжительности. Также известно, что кто-то оплатил количество показов.
Будем считать, что у нас известно количество оплаченных показов, общая стоимость всех показов и сам рекламный ролик.

1. Для связанного с рекламой функционала создадим пакет ad.

2. Создадим класс Advertisement(Рекламное объявление) в пакете ad, у которого будут следующие поля:
    - Object content - видео
    - String name - имя/название
    - long initialAmount - начальная сумма, стоимость рекламы в копейках. Используем long, чтобы избежать проблем с округлением
    - int hits - количество оплаченных показов
    - int duration - продолжительность в секундах
Модификаторы доступа расставь самостоятельно.

3. В классе Advertisement создадим конструктор с порядком аргументов, соответствующим перечисленной последовательности всех полей класса

4. В этом же пакете создадим еще два класса:
AdvertisementStorage - хранилище рекламных роликов.
AdvertisementManager - у каждого планшета будет свой объект менеджера,
который будет подбирать оптимальный набор роликов и их последовательность для каждого заказа.
Он также будет взаимодействовать с плеером и отображать ролики.

5. Так как хранилище рекламных роликов AdvertisementStorage единственное для всего ресторана, то сделаем его синглтоном.
<hr/>


[#### Ресторан(5)](https://github.com/vladmeh/jrt/commit/14646cf2d6f7dd1b3cf4001c347d6e1b39d21485)

Сейчас повар готовит блюда моментально. На самом деле приготовление занимает какое-то время.
Нам нужно вычислить время приготовления всего заказа, чтобы потом подбирать рекламные ролики для этого времени.

1.  Предположим, что нам известно время приготовления каждого блюда в минутах. Захардкодим его в классе Dish.
    1. Измени создание элементов enum - Fish(25), Steak(30), Soup(15), Juice(5), Water(3);
    2. Создай поле private int duration с геттером.
Чтобы создать геттер, нажмите Alt+Insert и выберите пункт Getter. Далее выберите имя поля и нажмите OK(Enter).

2.  Добавим возможность посчитать продолжительность приготовления всего заказа.
Куда его добавить???
    1. Если в класс Cook, то повар сможет считать продолжительность приготовления заказа.
Чтобы другие классы могли получить эту информацию, необходимо будет получить доступ к объекту Cook.
    2. Если в класс Order, то имея доступ к заказу всегда можно узнать продолжительность приготовления.
    3. Выбери правильное место из п.2.1. и п.2.2. и добавьте метод pubic int getTotalCookingTime(),
который посчитает суммарное время приготовления всех блюд в заказе.
    4. Добавим нашему повару вывод в консоль этой информации. Пусть теперь выводится аналогичное сообщение:

    `Start cooking - Your order: [Soup, Juice, Water] of Tablet{number=5}, cooking time 23min`

    Наведем красоту:

3. Запустим приложение и сразу введем 'exit'. Вывод получился не очень красивым.
Сделай так, чтобы если в заказе нет блюд, он не отправлялся повару. Найди это место и реализуйте логику.
В классе Order создай вспомогательный метод public boolean isEmpty(), который будет определять, есть ли какие либо блюда в заказе.
<hr/>



[#### Ресторан(4)](https://github.com/vladmeh/jrt/commit/7371598a08851fc1886d6efab278a19f250ddbcf)

Что мы имеем? Повар приготовил блюда, пора их уносить, а официант не знает об этом.
Нужно уведомить официанта, что пора забирать заказ с кухни.
Ситуация аналогична предыдущему заданию, поэтому снова будем использовать паттерн Observer.

1. Создадим класс Waiter(Официант) в пакете kitchen, он будет относить заказы назад к столику. Официант будет безымянным.

2. Cook(Повар) готовит заказы, а Waiter их обрабатывает. Расставь правильно Observer и Observable между Waiter и Cook.

3. Метод void update будет выводить в консоль сообщение о том, какой заказ и кем был приготовлен:
order + " was cooked by " + cook

4.  В классе наследнике Observable перед отправкой заказа сделаем следующее:
    1. Установим флаг setChanged()
    2. Отправим наблюдателю заказ - notifyObservers(order);

5. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

    `Сверим выводы в консоль. Пример моего вывода:
    Your order: [Water] of Tablet{number=5}
    Start cooking - Your order: [Water] of Tablet{number=5}
    Your order: [Water] of Tablet{number=5} was cooked by Amigo`
<hr/>



[#### Ресторан(3)](https://github.com/vladmeh/jrt/commit/e85bc732ce267185e39d42d4c8f8373c9d2ec992)

Сейчас мы можем создавать заказы. Давай сделаем так, чтобы они автоматически поступали к повару.
Есть много различных способов реализации данной функциональности.
Почитай про паттерн Observer - http://en.wikipedia.org/wiki/Observer_pattern
Он уже реализован в java, и мы его будем использовать.

1. Создадим класс Cook(Повар) в пакете kitchen, он будет готовить. Пусть в конструкторе приходит его имя, которое выводится методом toString.

2. Tablet создает заказы, а Cook их обрабатывает. Расставь правильно Observer и Observable между Tablet и Cook.

3. Метод void update(Observable observable, Object arg), который необходимо реализовать, принимает два параметра.
    - observable - объект, который отправил нам значение
    - arg - само значение, в нашем случае - это объект Order

    `На данном этапе мы будем лишь имитировать обработку и выведем в консоль "Start cooking - " + order`

3. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo : )

    `Сверим выводы в консоль. Пример моего вывода:
    Your order: [Soup] of Tablet{number=5}
    Start cooking - Your order: [Soup] of Tablet{number=5}`

4.  Не забудь сразу после создания заказа и вывода информации о нем в консоль (найдите это место в коде) сделать следующее:
    1. Установить флаг setChanged()
    2. Отправить обсерверу заказ - notifyObservers(order);

5. Также внесем небольшое изменение. Сделай так чтобы метод createOrder возвращал текущий заказ или null, если заказ создать не удалось.
<hr/>


[#### Ресторан(2)](https://github.com/vladmeh/jrt/commit/350b09c197239bc35c4f7084d4564b1f14e5c6ba)

1. Мы много работаем с консолью. Пора создать единую точку взаимодействия.
Создай класс ConsoleHelper с единственным BufferedReader, через который будем работать с консолью.
Запомни, этот класс не хранит никаких данных и состояний, поэтому все методы будут статическими.
Создай в нем три метода:
- writeMessage(String message) - для вывода message в консоль
- String readString() - для чтения строки с консоли
- List<Dish> getAllDishesForOrder() - просит пользователя выбрать блюдо и добавляет его в список.

Выведи список всех блюд и попроси пользователя ввести строку - название блюда.
Введенное 'exit' означает завершение заказа.
В случае, если введенное блюдо не представлено в меню, выведи сообщение о том, что такого блюда нет и продолжи формирование заказа.
Исключения ввода-вывода бросай выше, на этом уровне не понятно, что с ними делать.

2. Сделай рефакторинг - работа с консолью должна быть только через класс ConsoleHelper.

3. Вернемся к классу Order: в нем есть ссылка на планшет, и еще есть список выбранных блюд.
Инициализируй список dishes в конструкторе, вызвав метод getAllDishesForOrder из ConsoleHelper.

4. Перепиши метод toString в классе Order. Пусть он возвращает пустую строку, если нет блюд в заказе, иначе
вывод должен быть аналогичным примеру в порядке добавления блюд. Используй ConsoleHelper.
Также измени метод toString в классе Tablet (внутри класса Tablet нажмите Alt+Insert -> toString()).
Пример:
Your order: [Juice, Fish] of Tablet{number=5}

5. У нас все завязано на работу с консолью. Однако, при возникновении исключений, наше приложение умрет.
Чтобы узнать причину - добавим в Tablet статическое поле logger типа java.util.logging.Logger, инициализированное именем класса (Logger.getLogger(Tablet.class.getName())).

6. В методе createOrder класса Tablet обработаем исключения ввода-вывода.
Запишем в лог "Console is unavailable.". Уровень лога - SEVERE - это самый серьезный уровень, мы не можем работать.
Также в методе createOrder класса Tablet должен быть создан новый заказ.

7. Надо начинать тестировать наше приложение.
Добавьте в main создание планшета и создание заказа - new Tablet(5).createOrder();
<hr/>


[#### Ресторан(1)](https://github.com/vladmeh/jrt/commit/29be48b18886a6d40587d6aa63ceb3f52108deb3?diff=unified)

Давай напишем программу для автоматизации работы в ресторане.

Пусть задание сформулировано так - директор ресторана хочет, чтобы:
1.  на каждом столике лежал планшет, через который можно было бы сделать заказ;
2.  пока заказ готовится, на планшете показывалась реклама;
3.  в конце рабочего дня была возможность посмотреть различную статистику:
    а) загрузки повара;
    б) сумму выручки за заказы;
    в) сумму выручки за показы рекламы.

Мы будем разрабатывать ядро, без UI. UI ты потом сможешь дописать самостоятельно, сейчас ограничимся консольным интерфейсом.
Также мы часть данных захардкодим, ты потом сможешь прикрутить БД, и работать с ней.

Выделим несколько фич, которые будем реализовывать:

Первая:
- созданный посетителем заказ будет автоматически поступать к повару;
- повар будет готовить его какое-то время и отмечать приготовленным;
- после этого официант будет относить его.

Вторая:
- подобрать нужные рекламные ролики из списка оплаченных;
- отображение рекламных роликов во время приготовления заказа;
- максимизировать прибыль от показа рекламы.

Третья:
- подсчет статистики;
- отображение статистики директору.

Начнем с первой фичи - автоматизация обработки заказа:

Итак..
1. Создай класс Restaurant с методом main.

2. Начнем с планшета, создадим класс Tablet, в котором создадим поле final int number - это номер планшета,
чтобы можно было однозначно установить, откуда поступил заказ. Номер планшета должен инициализироваться в конструкторе переданным параметром.

3. В классе Tablet создадим метод public void createOrder(), который будет создавать заказ из тех блюд, которые выберет пользователь.
Для этого создадим класс Order, который поместим в пакет kitchen.

4. В классе Order (заказ) должна быть информация, относящаяся к списку выбранных пользователем блюд.
Т.е. где-то должен быть список всех блюд, и должен быть список выбранных блюд в классе Order.
В классе Order нужны поля **private final Tablet tablet** и **protected List<Dish> dishes**.
Конструктор должен принимать один параметр типа Tablet и инициализировать поле tablet.

5. Нам нужен класс Dish(Блюдо), создадим его в пакете kitchen. Пусть это будет enum со списком блюд: Fish, Steak, Soup, Juice, Water.

6. Чтобы пользователь мог выбрать себе блюда, нужно их все ему отобразить. Для этого в Dish создай метод
public static String allDishesToString(), который сформирует строку из всех блюд.
Пример: "Fish, Steak, Soup, Juice, Water". Формируй строку динамически.
<hr/>