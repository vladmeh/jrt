package string;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * @autor mvl on 27.07.2017.
 */
public class MathStringParser {
    private static final List<Character> OPERATORS = Arrays.asList('+', '-', '*', '/', '^');

    /**
     * создаем функцию, возвращающую true,
     * если наш переданный в параметре символ c
     * +, -, * или / . Иначе - false.
     */
    private static boolean isOperator(char ch) {
        return OPERATORS.contains(ch);
    }

    /**
     * создаем функцию возврата приоритета в виде числа,
     * которая принимает параметр символа oper
     */
    private static int priority(char oper) {
        switch (oper){
            case '^':
                return 2;
            case '*':
            case '/':
                return 1;
            case '+':
            case '-':
                return 0;
            default: return -1;
        }
    }

    /**
     * Пишем метод, который принимает два параметра -
     * LinkedList и char. LinkedList'у мы строго говорим,
     * что он принимает Integer (число).
     * Данный метод "учит" считать программу.
     * LinkedList используется т.к. он умеет обращаться
     * к началу и концу своего списка, а т.к. у нас стековый
     * алгоритм, то нам нужно это уметь.
     */
    private static void letGo(LinkedList<Integer> st, char oper) {

        // Инициализируем и объявляем две переменные
        // Первая берет последнее значение из переданного
        // связанного листа в параметре, запоминает и удаляет
        // его из списка
        int someOne = st.removeLast();

        // Тоже самое делаем со второй переменной
        int someTwo = st.removeLast();

        // Пишем switch (можно if, но он длиннее по коду),
        // который учит переданный символ во 2 параметре
        // считать относительно своему предназначению
        switch(oper) {
            case '+':
                st.add(someTwo + someOne);
                break;
            case '-':
                st.add(someTwo - someOne);
                break;
            case '*':
                st.add(someTwo * someOne);
                break;
            case '/':
                st.add(someTwo / someOne);
                break;
            case '^':
                st.add((int)Math. pow(someTwo, someOne));
                break;
            default:
                System.out.println("Oops");
        }
    }

    // Создаем функцию, которая возвращает значение
    // типа int (не будем вдаваться в плавающие точки),
    // принимающая параметр нашей строки (например: "(2+2)*2").
    private static int eval(String s) {

        // Создаем два контейнера типа LinkedList
        // Один для чисел, другой для символов
        LinkedList<Integer> someInts = new LinkedList<>();
        LinkedList<Character> someOpers = new LinkedList<>();

        // Пишем цикл, который бегает по нашей строке
        for(int i = 0; i < s.length(); i++) {

            // Создаем локальную переменную типа символ,
            // чтобы было с чем делать сравнения и работать.
            // Присваиваем ей текущее положение i в строке
            char c = s.charAt(i);

            // Если натыкаемся на открывающуюся скобку
            if(c == '(') {

                // Добавляем открывающуюся скобку в контейнер
                // символов
                someOpers.add('(');

            }

            // Если натыкаемся на закрывающуюся скобку
            else if (c == ')') {

                // Смотрим - пока последний символ контейнера
                // символов не открывающаяся скобка -
                // Выполняем метод, который учит считать
                // программу, передавая ему в параметрах
                // наш контейнер с числами и последний
                // символ в контейнере символов, причем
                // удаляя его опосля
                // Например:
                //
                // Числовой Контейнер:   { 2, 2 }
                // Символьный Контейнер: { (, + }
                //
                // Передаем letGo({2,2},'+');
                //
                // На выходе:
                //
                // Числовой Контейнер:   { 4 }
                // Символьный Контейнер: { ( }
                while(someOpers.getLast() != '(') {
                    letGo(someInts, someOpers.removeLast());
                }

                // После while - удаляем последний символ
                // из Символьного Контейнера. Если смотреть
                // пример - это открывающаяся скобка
                someOpers.removeLast();

            }

            // Так же, во время цикла мы проверяем каждый символ
            // на предмет - а не оператор ли он часом?
            // Если же да, то
            // ПОКА массив символов непустой и приоритет
            // последнего символа в контейнере символов
            // больше или равен приоритету текущего -
            // "учим" программу считать, передавая в параметрах
            // контейнер с числами и последний символ из
            // контейнера символов, удаляя его опосля
            // Например:
            //
            // Наш символ: +
            // Числовой Контейнер:   { 2, 2 }
            // Символьный Контейнер: { * }
            //
            // Согласно условию:
            //                    СК         не пустой
            //                    Приоритет  '*' > '+'
            //
            // Передаем letGo({2,2},'*');
            //
            // На выходе:
            //
            // Числовой Контейнер:   { 4 }
            // Символьный Контейнер: { + }
            // Кривой пример, конечно, но смысл должен быть ясен
            else if (isOperator(c)) {
                while(!someOpers.isEmpty() &&
                        priority(someOpers.getLast()) >= priority(c)) {

                    letGo(someInts, someOpers.removeLast());

                }

                // Если while не выполняется - добавляем
                // символ в контейнер символов
                someOpers.add(c);
            }

            // Если же ничего из вышеперечисленного не произошло,
            // то мы ожидаем число
            else {

                // Так как мы можем получить не только простые
                // числа (1, 5, 9), но и - 11, 344, 53432 и т.д.,
                // нам нужна локальная строка
                String operand = "";

                // После чего, ПОКА
                // текущее i меньше размера строки и
                // позиция от i в строке - число, -
                // мы составляем строку числа из символов,
                // увеличивая i на 1 каждый раз, когда символ
                // записался, чтобы проверять строку дальше
                while(i < s.length() &&
                        Character.isDigit(s.charAt(i))) {
                    operand += s.charAt(i++);
                }

                // Если while не выполнился или закончился -
                // отнимаем у i единицу (т.к. i++ отработала
                // лишний раз, и добавляем нашу
                // распарсенную в числовой манер строку,
                // которую мы составили из чисел в
                // Числовой Контейнер
                --i;
                someInts.add(Integer.parseInt(operand));
            }
        }

        // После цикла,
        // ПОКА контейнер символов НЕ пустой, -
        // "учим" считать программу, передавая ей наш контейнер
        // чисел и контейнер символов. Обычно, этот while
        // отрабатывает в конце, что логично, т.к. мы
        // предусмотрели все условия и на момент
        // окончания цикла у нас только остатки
        // например, если бы у нас было:
        // (2+2)*(4+5)
        // на момент этого while, у нас бы осталось:
        // КЧ: { 4,9 }
        // КС: { * }
        while(!someOpers.isEmpty()) {
            letGo(someInts, someOpers.removeLast());
        }

        // В конце мы возвращаем наше получившееся значение из
        // Контейнера чисел. Глядя на последний пример -
        // получится 36
        return someInts.get(0);
    }

    private static void evalTrig(String s){
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            System.out.print(c);
            if (c == 's' || c == 'c' || c == 't'){
                i += 2;
                /*for (int j = i; j < i+3; j++) {
                    char cf = s.charAt(j);
                    System.out.print(cf);
                }*/
            }
        }
    }

    public static void main(String[] args) {
        //System.out.println(eval("(2+2)*(4+5)"));
        //System.out.println(eval("3^3"));
        //System.out.println(eval("((2+2.2)*(4+5))^3"));
        evalTrig("sin(2*(-5+1.5*4)+28)");
        System.out.println();
        evalTrig("cos(3 + 19*3)");
        System.out.println();
        evalTrig("tan(45)");
    }
}
